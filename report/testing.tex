Testing was a constant process, with each new feature invariably requiring
thorough inspection. As the project progressed, the testing strategy graduated
from unit tests to more extensive general tests. Unit tests were performed on
the two main components of the translator. Once they were working properly,
testing consisted mainly of verifying various features through a series of
example Scheme programs.


\section{Unit Tests}
Unit tests were used to iron out the early bugs in the scanner and parser. They
were in the form of Lua scripts. As an example, here is the script used to test
the scanner by creating temporary test scheme files and verifying the characters
and tokens produced by the scanner.
\begin{framed}
\scriptsize
\begin{verbatim}
require("scanner")

--
-- Create test input file
--
io.output("/tmp/s2ltest_chars.scm")
io.write("(+ 1 2)\n")
io.write("(display \"abc\")\n")
io.close()

io.output("/tmp/s2ltest_tokens.scm")
io.write("(newline) ; This should print a newline\n")
io.write("#| Commented out section\n")
io.write("(+ 1 2)\n")
io.write("(define x #| Nested #| Another nest |# block comment |# 5)\n")
io.write("(display \"abc\")\n")
io.write("End of commented out section |#\n")
io.write("; Another one-line comment|#\n")
io.write("(lambda (->x) (+ ->x 1))\n")
io.write("(* (+ 3 5) 2 3)\n")
io.close()

io.output(io.stdout)

characters = {
    "(", "+", " ", "1", " ", "2", ")", "\n",
    "(", "d", "i", "s", "p", "l", "a", "y", " ",
    "\"", "a", "b", "c", "\"", ")", "\n", 
}

tokens = {
    {"("}, {"symbol", "newline"}, {")"},
    {"("}, {"symbol", "lambda"},
	{"("}, {"symbol", "->x"}, {")"},
	{"("}, {"+"}, {"symbol", "->x"}, {"number", 1}, {")"},
    {")"},
    {"("}, {"symbol", "*"},
	{"("}, {"+"}, {"number", 3}, {"number", 5}, {")"},
	{"number", 2}, {"number", 3},
    {")"}
}

--
-- Run tests
--

-- Test char functions
io.input("/tmp/s2ltest_chars.scm")
scanner.init()
local index = 1
while scanner.peekChar() ~= "" do
    assert(scanner.peekChar() == characters[index]
    and scanner.nextChar() == characters[index])
    index = index + 1
end

-- Test token functions
io.input("/tmp/s2ltest_tokens.scm")
scanner.init()
index = 1
while scanner.peekToken() ~= "EOF" do
    local token, value = scanner.peekToken()
    assert(token == tokens[index][1] and value == tokens[index][2])
    token, value = scanner.nextToken()
    assert(token == tokens[index][1] and value == tokens[index][2])
    index = index + 1
end

print("Scannertest: All tests passed")
\end{verbatim}
\end{framed}


\section{Scheme Test Programs}

Below are some excerpts from the programs that were used. They were made to be
increasingly complex and to test different aspects of the translator. A more
complete example, including the translation and program output can be found in
Appendix~\ref{sec:transexample}

\subsection{Test Program 1}
This example tested basic operations, such as displaying output, quoting data
and constructing proper and improper lists.
\begin{framed}
\begin{verbatim}
(display '())
(newline)
(display (quote (1 #t 3)))
(newline)
(display '(1 2 . 3))
(newline)
(display (cons 4 (cons '("Hello" 3) '(1 2 . 3))))
(newline)
\end{verbatim}
\end{framed}

\subsection{Test Program 2}
This example tested simple definitions and function application.
\begin{framed}
\begin{verbatim}
(define identity (lambda (x) x))
(display (identity 5))

(display ((lambda (x) (+ x 1)) 2))
(newline)

(define a
  (lambda (n) (+ n 5)))
(define b
  (lambda (x y) (+ x y)))

(display "(b (a 3) (b 2 2))")
(newline)
(display (b (a 3) (b 2 2)))
(newline)
\end{verbatim}
\end{framed}

\subsection{Test Program 3}
This program was used to test the different ways of handling arguments in the
lambda expression.
\begin{framed}
\begin{verbatim}
(display ((lambda (x) x) 5))
(newline)
(display ((lambda x x) 5))
(newline)
(display ((lambda (x . y) y) 1 2 3))
(newline)
\end{verbatim}
\end{framed}

\subsection{Test Program 4}
This program tested some more comprehensive function definitions, including
branching and recursion.
\begin{framed}
\begin{verbatim}
(define IsInteger
  (lambda (x)
    (integer? x)))

(define Last
  (lambda (l)
    (cond
      ((null? (cdr l)) (car l))
      (else (Last (cdr l))))))

(define Range
  (lambda (lo hi)
    (cond
      ((> lo hi) '())
      (else (cons lo (Range (+ lo 1) hi))))))

(display (Range 1 5))
(display (Last '(9 8 7 6 5 4)))
\end{verbatim}
\end{framed}


\section{Performance Tests}

Two prime number algorithms were used to test the relative performance of the
translation against a native Scheme implementation. Also included is the result
of running the translated Lua output using \texttt{luaJIT}, the Lua just-in-time
compiler. The algorithms were intentionally na\"{i}ve, with the second being
a more list-based variation.

\subsection{Algorithm 1}

\begin{framed}
\begin{verbatim}
(define primes
  (lambda (n)
    (let nextprime ((primecount 1) (current 2))
      (cond
        ((> primecount n) (newline))
        ((isPrime current)
         (display primecount) (display ": ")
         (display current) (newline)
         (nextprime (+ primecount 1) (+ current 1)))
        (else (nextprime primecount (+ current 1)))))))

(define isPrime
  (lambda (n)
    (if (< n 2) #f
      (let prime ((k 2))
        (cond
          ((= n k) #t)
          ((integer? (/ n k)) #f)
          (else (prime (+ k 1))))))))

(primes 5000)
(exit)
\end{verbatim}
\end{framed}

\begin{center}
\begin{tabular}{|l|c|c|c|}
\hline
& lua & luaJIT & scm \\
\hline
First 1000 Primes & 0:16 & 0:09 & 0:02 \\ \hline
First 2000 Primes & 1:13 & 0:41 & 0:09 \\ \hline
First 5000 Primes & 8:26 & 4:49 & 1:02 \\ \hline
\end{tabular}
\end{center}

\subsection{Algorithm 2}

\begin{framed}
\begin{verbatim}
(define Range
  (lambda (lo hi)
    (cond
      ((> lo hi) '())
      (else (cons lo (Range (+ lo 1) hi))))))

(define Filter
  (lambda (p l)
    (cond
      ((null? l) '())
      ((p (car l)) (cons (car l) (Filter p (cdr l))))
      (else (Filter p (cdr l))))))

(define isPrime
  (lambda (n)
    (if (< n 2) #f
      (let prime ((k 2))
        (cond
          ((= n k) #t)
          ((integer? (/ n k)) #f)
          (else (prime (+ k 1))))))))

(display (Filter isPrime (Range 2 20000)))
(newline)
(exit)
\end{verbatim}
\end{framed}

\begin{center}
\begin{tabular}{|l|c|c|c|}
\hline
& lua & luaJIT & scm \\
\hline
Primes Up To 10000 & 0:37 & 0:16 & 0:03 \\ \hline
Primes Up To 20000 & FAIL & 1:13 & FAIL \\ \hline
\end{tabular}
\end{center}
